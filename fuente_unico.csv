abrir_archivos,'(lista)', 'modulo_merge.py', 'rutas_arch_abiertos = []', 'for i in range(len(lista)):', 'rutas_arch_abiertos.append(open(lista[i], "r"))', 'return rutas_arch_abiertos', ''
buscar_autor,'(lista_comentarios)', 'generador_csv.py', 'autor = 0', 'for k in range(len(lista_comentarios)):', 'if "autor:" in lista_comentarios[k].lower():', 'devolver = lista_comentarios[k].lstrip(" ").rstrip("\\n").lstrip(comentario_multiple)', 'autor += 1', 'if autor < 1:', 'devolver = "[Autor: Sin autor]"', 'return devolver', '', ''
buscar_ayuda,'(lista_comentarios)', 'generador_csv.py', 'ayuda = 0', 'for j in range(len(lista_comentarios)):', 'if "ayuda" in lista_comentarios[j].lower():', 'devolver = lista_comentarios[j].lstrip(" ").rstrip("\\n")', 'ayuda += 1', 'if ayuda < 1:', 'devolver = "[Ayuda: Sin ayuda]"', 'return devolver', '', ''
buscar_due침o,'(linea)', 'panel_general_funciones.py', 'lista = linea.split(",")', 'return lista[1]', '', ''
buscar_due침o,'(linea)', 'informacion_desarrollador.py', 'lista = linea.split(",")', 'return lista[1]', ''
buscar_funcion,'(linea)', 'informacion_desarrollador.py', 'lista = linea.split(",")', 'return lista[0]', '', ''
buscar_funcion_modulo,'(linea)', 'panel_general_funciones.py', 'lista = linea.split(",")', 'for campo in lista:', 'if ".py\'" in campo:', 'devolver = lista[0] + campo.rstrip("\'")', 'return devolver.replace(" \'", ".")', ''
calc_porcentaje,'(total_lineas, lineas_funcion)', 'informacion_desarrollador.py', 'porcentaje = int(round((lineas_funcion * total_lineas) / 100, 0))', 'return porcentaje', ''
calc_total_lineas,'(dic_participacion)', 'informacion_desarrollador.py', 'total_lineas = 0', 'for autor in dic_participacion:', 'dic_part_ord = dict(sorted(dic_participacion[autor].items(), key=lambda item: item[1], reverse=True))', 'for funcion in dic_part_ord:', 'total_lineas += dic_part_ord[funcion]', 'return total_lineas', ''
capicuas,'(list_words)', '6-show-capicuas-ordered-unrepeated.py', 'len_lista = len(list_words)', 'for i in range(len_lista):', 'palabra = list_words[i].lower()', '', 'invertida = ""', 'for j in range(len(palabra)-1, -1, -1):', 'invertida += palabra[j]', 'if palabra == invertida:', '', 'lista_capicuas.append(palabra)', 'return lista_capicuas', '', '', '', ''
carga_dic_participacion,'(fuente_unico, comentarios)', 'informacion_desarrollador.py', 'dic_participacion = {}', 'linea = fuente_unico.readline()', 'linea_c = comentarios.readline()', 'while linea:', '', 'au = buscar_due침o(linea_c).lstrip("\'").rstrip("\'")', 'funcion = buscar_funcion(linea)', 'cant_lineas = count_lineas_codigo(linea)', '', 'if au not in dic_participacion:', 'dic_participacion[au] = {funcion: cant_lineas}', 'else:', 'dic_participacion[au].update({funcion: cant_lineas})   ', 'linea = fuente_unico.readline()', 'linea_c = comentarios.readline()', 'return dic_participacion', ''
cargar_dic_coment,'(key, autor, ayuda, otros)', 'generador_csv.py', 'dict_comentarios[key] = [autor, ayuda]', 'dict_comentarios[key].extend(otros)', ''
cerrar_archivos,'(lista)', 'modulo_merge.py', 'for i in range(len(lista)):', 'lista[i].close()', ''
count_comentarios,'(linea)', 'panel_general_funciones.py', 'lista = linea.split("]\',")', 'if len(lista) > 2:', 'comentarios_extra = lista[2].split("\',")', 'devolver = len(comentarios_extra)', 'else:', 'devolver = 0', 'return devolver', '', ''
count_ifs,'(linea)', 'panel_general_funciones.py', 'contador = 0', 'lista_linea_codigo = gen_lista_linea_codigo(linea)', 'for campo in lista_linea_codigo:', '', 'if "if " in campo or "elif " in campo: ', 'contador += 1', 'return contador', '', ''
count_invocaciones,'(fuente_unico)', 'panel_general_funciones.py', 'l_funciones = []', 'dic_contador = {}', 'fuente_unico.seek(0)', 'linea = fuente_unico.readline()', '', 'while linea:', 'splits = linea.split(",")', 'l_funciones.append(splits[0])', 'linea = fuente_unico.readline()', '', 'for i in range(len(l_funciones)):', 'fuente_unico.seek(0)', 'linea = fuente_unico.readline()', 'while linea:', 'if (l_funciones[i] + "(") in linea:', 'if l_funciones[i] in dic_contador:', 'dic_contador[l_funciones[i]] += 1', 'else:', 'dic_contador[l_funciones[i]] = 0', 'linea = fuente_unico.readline()', 'if l_funciones[i] not in dic_contador:', 'dic_contador[l_funciones[i]] = 0', '', 'return dic_contador', ''
count_lineas_codigo,'(linea)', 'panel_general_funciones.py', 'lista_sin_vacios = []  ', 'lista_linea_codigo = gen_lista_linea_codigo(linea)', '', 'for campo in lista_linea_codigo:', 'if campo != "\'\'" and campo != "\'":', 'lista_sin_vacios.append(campo)', '', 'return len(lista_sin_vacios)', '', ''
count_lineas_codigo,'(linea)', 'informacion_desarrollador.py', 'lista_sin_vacios = []  ', 'lista_linea_codigo = gen_lista_linea_codigo(linea)', '', 'for campo in lista_linea_codigo:', 'if campo != "\'\'" and campo != "\'":', 'lista_sin_vacios.append(campo)', '', 'return len(lista_sin_vacios)', '', ''
count_palabra,'(linea, palabra_buscada)', 'panel_general_funciones.py', '', 'buscar = palabra_buscada + " " ', 'contador = 0', 'lista_linea_codigo = gen_lista_linea_codigo(linea)', 'for campo in lista_linea_codigo:', 'if buscar in campo: ', 'contador += 1', 'return contador', ''
count_parametros,'(linea)', 'panel_general_funciones.py', 'lista = linea.split("\'")', 'devolver = lista[1].split(",")', 'return len(devolver)', ''
delete_repeated,'(lista)', '6-show-capicuas-ordered-unrepeated.py', 'new_list = []', 'long = len(lista)', 'for i in range(long): ', '', 'if not lista[i] in new_list:', 'new_list.append(lista[i])', '', 'return new_list', '', ''
encontrar_llave_param,'(linea)', 'generador_csv.py', 'aux = linea.split(" ", 1)', 'aux2 = aux[1].split("(", 1)', 'key = aux2[0]', 'param = "(" + aux2[1].rstrip(":\\n")', 'return key, param', '', ''
es_primo,'(valor)', 'lib_matematica.py', '', 'devolver = True', 'if valor <= 1:', 'devolver = False', 'else:', '', 'divisor = 2', 'while (((valor % divisor)!=0) and (divisor <= valor/2)):', 'divisor += 1', '', 'if divisor <= valor/2:', 'devolver = False', '', 'return devolver', ''
escribir_info_desarrollador,'(arch_salida, total_lineas, dic_participacion)', 'informacion_desarrollador.py', 'contador = 0', 'arch_salida.write("Informe de Desarrollo Por Autor \\n")', 'for autor in dic_participacion:', 'arch_salida.write(autor + "\\n")', 'arch_salida.write(\'{:^30}{:^10}\'.format("FUNCION", "L츞xadneas") + "\\n")', '', 'arch_salida.write(\'{:^30}{:^10}\'.format("-----------------------------", "----------") + "\\n")', 'dic_part_ord = dict(sorted(dic_participacion[autor].items(), key=lambda item: item[1], reverse=True))', 'for funcion in dic_part_ord:', 'arch_salida.write(\'{:^30}{:^10}\'.format(funcion, dic_part_ord[funcion]) + "\\n")', 'contador += dic_part_ord[funcion]', 'arch_salida.write("\\n")', 'porcentaje = calc_porcentaje(total_lineas, contador)', 'arch_salida.write(\'{:^30}{:^10}{:^10}\'.format(str(len(dic_part_ord)) + " Funciones - Lineas", contador, str(porcentaje) + "%") + "\\n")   ', 'contador = 0', 'arch_salida.write(\'{:^30}{:^10}\'.format("-----------------------------", "----------") + "\\n")', 'arch_salida.write("\\n")', ''
escribir_panel_general,'(arch_salida, funcion, parametros, lineas, invocaciones, returns, ifs, fors, whiles, breaks, exits, coments, ayudas, autores)', 'panel_general_funciones.py', 'escribir = funcion + ", " + str(parametros) + ", " + str(lineas) + ", " + str(invocaciones)+ ", " + str(returns) + ", " + str(ifs) + ", " + str(fors) + ", " + str(whiles) + ", " + str(breaks) + ", " + str(exits) + ", " + str(coments) + ", " + ayudas + ", " + autores + "\\n"', 'arch_salida.write(escribir)', '', ''
escribir_registros,'(archivo, diccionario)', 'generador_csv.py', 'for key in diccionario:', 'registros = str(diccionario[key]).rstrip("]").lstrip("[")', 'linea = key + "," + registros + "\\n"', 'archivo.write(linea)', '', ''
factorial,'(n)', 'lib_matematica.py', '', 'resultado = 1', 'for i in range(2, n+1):', 'resultado = resultado * i', '', 'return resultado', ''
gen_lista_linea_codigo,'(linea)', 'panel_general_funciones.py', 'linea = linea.rstrip("\\n")', 'lista = linea.split(".py\', ") ', 'lista_linea_codigo = lista[1].split("\', ") ', '', 'return lista_linea_codigo', '', ''
gen_lista_linea_codigo,'(linea)', 'informacion_desarrollador.py', 'linea = linea.rstrip("\\n")', 'lista = linea.split(".py\', ") ', 'lista_linea_codigo = lista[1].split("\', ") ', '', 'return lista_linea_codigo', '', ''
generar_dict_comentarios,'(codigo)', 'generador_csv.py', 'lista_comentarios = []', 'linea = leer_linea(codigo)', 'while linea:', 'nom_funcion = re.search(palabra_func, linea)', 'if nom_funcion:', 'key, parametros = encontrar_llave_param(linea)', 'linea = leer_linea(codigo)', '', "while re.match(r'\\s', linea): ", 'if comentario_multiple in linea:', 'lista_comentarios.append(linea)', 'linea = leer_linea(codigo)', 'while not comentario_multiple in linea:', 'lista_comentarios.append(linea)', 'linea = leer_linea(codigo)', 'linea = leer_linea(codigo)', 'elif comentario_simple in linea:', 'agregar = linea.split("', 'lista_comentarios.append(agregar[1].rstrip("\\n"))', 'linea = leer_linea(codigo)', 'else:', 'linea = leer_linea(codigo)', 'cargar_dic_coment(key, buscar_autor(lista_comentarios), buscar_ayuda(lista_comentarios), otros_coments(lista_comentarios))', 'lista_comentarios.clear()', 'else:', 'linea = leer_linea(codigo)', 'lista_comentarios.clear()', 'return dict_comentarios', '', ''
generar_dict_funciones,'(codigo)', 'generador_csv.py', 'linea = leer_linea(codigo)', 'while linea:', 'nom_funcion = re.search(palabra_func, linea)', 'if nom_funcion:', 'key, parametros = encontrar_llave_param(linea)', 'dict_funciones[key] = [parametros, os.path.basename(codigo.name)]', 'linea = leer_linea(codigo)', "while re.match(r'\\s', linea):", '', 'if comentario_multiple in linea: ', 'linea = leer_linea(codigo)', 'while not comentario_multiple in linea:', 'linea = leer_linea(codigo)', 'linea = leer_linea(codigo)', 'elif comentario_simple in linea:', 'linea = linea.lstrip(" ")', 'l_split = linea.split("', 'if l_split[0] != "\'\'":', 'dict_funciones[key].append(l_split[0])', 'linea = leer_linea(codigo)', 'else:', 'linea = leer_linea(codigo)', 'else:', 'dict_funciones[key].append(linea.strip(" ").rstrip("\\n"))', 'linea = leer_linea(codigo)', 'else:', '', 'linea = leer_linea(codigo)           ', 'return dict_funciones', '', ''
guardar,'(arch, nom_funcion, extras)', 'modulo_merge.py', 'datos_extras = []', '', 'for extra in extras:', 'datos_extras.append(str(extra))', 'extras_formato = ",".join(datos_extras)', 'arch.write(str(nom_funcion) + "," + extras_formato + "\\n")', ''
hay_ayuda,'(linea)', 'panel_general_funciones.py', 'lista = linea.split(",")', 'if lista[2] == " \'[Ayuda: Sin ayuda]\'":', 'devolver = "NO"', 'else:', 'devolver = "SI"', 'return devolver', ''
imprimir_info_desarrollador,'(total_lineas, dic_participacion)', 'informacion_desarrollador.py', 'contador = 0', 'print("Informe de Desarrolo Por Autor \\n")', 'for autor in dic_participacion:', 'print(autor)', 'print(\'{:^30}{:^10}\'.format("FUNCION", "L츞xadneas"))', 'print(\'{:^30}{:^10}\'.format("-----------------------------", "----------"))', 'dic_part_ord = dict(sorted(dic_participacion[autor].items(), key=lambda item: item[1], reverse=True))', 'for funcion in dic_part_ord:', "print('{:^30}{:^10}'.format(funcion, dic_part_ord[funcion]))", 'contador += dic_part_ord[funcion]', 'print("\\n")', 'porcentaje = calc_porcentaje(total_lineas, contador)', 'print(\'{:^30}{:^10}{:^10}\'.format(str(len(dic_part_ord)) + " Funciones - Lineas", contador, str(porcentaje) + "%"))   ', 'contador = 0', 'print(\'{:^30}{:^10}\'.format("-----------------------------", "----------"))', 'print("\\n")', ''
leer,'(arch)', 'modulo_merge.py', 'linea = arch.readline()', 'if linea:', 'devolver = linea.rstrip("\\n").split(",")       ', 'else:', 'devolver = (MAX_NOM_FUNCION, "fin")', 'return devolver', ''
leer_linea,'(archivo)', 'generador_csv.py', 'linea = archivo.readline()', 'return linea', '', ''
leer_lineas,'(l_arch)', 'modulo_merge.py', 'lineas = []', 'for arch in l_arch:', 'linea = leer(arch)', 'lineas.append(linea)', 'return lineas', ''
main_generador,'(archivo)', 'generador_csv.py', 'l_fun = []', 'l_com = []', 'programas = open(archivo, "r")', 'l_fun.clear()', 'l_com.clear()', 'linea = leer_linea(programas)', 'while linea:', 'ruta = linea.rstrip("\\n")', 'codigo = open(ruta, "r")', 'dict_funciones = generar_dict_funciones(codigo)', 'dict_funciones_ordenado = ordenar_dict(dict_funciones)', 'ruta_csv_funciones = "./salidas/csv_funciones_" + os.path.basename(codigo.name).rstrip(".py") + ".csv"', 'guardar = open(ruta_csv_funciones, "w")', 'escribir_registros(guardar, dict_funciones_ordenado)', 'guardar.close()', 'l_fun.append(ruta_csv_funciones)', '', 'codigo.seek(0)', '', 'dict_comentarios = generar_dict_comentarios(codigo)', 'dict_comentarios_ordenado = ordenar_dict(dict_comentarios)', 'ruta_csv_comentarios = "./salidas/csv_comentarios_" + os.path.basename(codigo.name).rstrip(".py") + ".csv"', 'guardar = open(ruta_csv_comentarios, "w")', 'escribir_registros(guardar, dict_comentarios_ordenado)', 'guardar.close()', 'l_com.append(ruta_csv_comentarios)', 'codigo.close()', 'dict_funciones.clear()', 'dict_comentarios.clear()', '', 'linea = leer_linea(programas)', 'return l_fun, l_com', '', '', '', ''
main_informacion_desarrollador,'(fuente_unico, comentarios, salida):  ', 'informacion_desarrollador.py', 'dic_participacion = carga_dic_participacion(fuente_unico, comentarios)', 'total_lineas = calc_total_lineas(dic_participacion)', 'imprimir_info_desarrollador(total_lineas, dic_participacion)', 'escribir_info_desarrollador(salida, total_lineas, dic_participacion)', 'print("*Genere el participacion.txt, ubicado en la carpeta de salidas_modulos")', ''
main_modulo_merge,'(lista_funciones, lista_comentarios)', 'modulo_merge.py', '', '', 'rutas_arch_abiertos = abrir_archivos(lista_comentarios) ', 'salida = "comentarios.csv"', 'arch_salida = open(salida, "w")', '', 'merge(arch_salida, *rutas_arch_abiertos) ', '', 'arch_salida.close()', 'cerrar_archivos(rutas_arch_abiertos) ', '', '', 'rutas_arch_abiertos = abrir_archivos(lista_funciones) ', 'salida = "fuente_unico.csv"', 'arch_salida = open(salida, "w")', '', 'merge(arch_salida, *rutas_arch_abiertos)', '', '', 'arch_salida.close()', 'cerrar_archivos(rutas_arch_abiertos) ', '', '', '', '', '', ''
main_panel_general_funciones,'(fuente_unico, comentarios, arch_salida)', 'panel_general_funciones.py', 'dic_invocaciones = count_invocaciones(fuente_unico)', 'fuente_unico.seek(0)', 'linea = fuente_unico.readline()', 'linea_c = comentarios.readline()', 'arch_salida.write("FUNCION, PARAMETROS, LINEAS, INVOCACIONES, RETURNS, IF, FOR, WHILE, BREAKS, EXITS, COMENTS, AYUDAS, AUTORES\\n")', 'print(\'{:^55}{:^10}{:^10}{:^10}{:^10}{:^10}{:^5}{:^10}{:^10}{:^10}{:^10}{:^10}{:^25}\'.format("FUNCION", "Par치metros", "L츞xadneas","Invocaiones","Returns","If/elif","for","while","break","Exit","Coment","Ayuda", "Autor"))', 'while linea:', '', 'l_funcion_actual = linea.split(",")', 'funcion_actual = l_funcion_actual[0]', 'escribir_panel_general(arch_salida, buscar_funcion_modulo(linea), count_parametros(linea), count_lineas_codigo(linea), dic_invocaciones[funcion_actual], count_palabra(linea, "return"), count_ifs(linea), count_palabra(linea, "for"), count_palabra(linea, "while"), count_palabra(linea, "break"), count_palabra(linea, "exit"), count_comentarios(linea_c), hay_ayuda(linea_c), buscar_due침o(linea_c))', 'print(\'{:^55}{:^10}{:^10}{:^10}{:^10}{:^10}{:^5}{:^10}{:^10}{:^10}{:^10}{:^10}{:^25}\'.format(buscar_funcion_modulo(linea), count_parametros(linea), count_lineas_codigo(linea), dic_invocaciones[funcion_actual],count_palabra(linea, "return"),count_ifs(linea),count_palabra(linea, "for"),count_palabra(linea, "while"),count_palabra(linea, "break"),count_palabra(linea, "exit"),count_comentarios(linea_c),hay_ayuda(linea_c), buscar_due침o(linea_c)))', 'linea = fuente_unico.readline()', 'linea_c = comentarios.readline()', 'print("-------------------------------------------------------")', 'print("\\nGenere el panel general.csv")', 'print("*Los datos han sido registrados en panel_general.csv, ubicado en la carpeta de salidas_modulos")', ''
make_list,'(txt)', '6-show-capicuas-ordered-unrepeated.py', 'word_list = txt.split() ', '', 'return word_list', '', ''
mcd,'(nro_1, nro_2)', 'lib_matematica.py', '', 'if abs(nro_1) < abs(nro_2):', 'menor = abs(nro_1)', 'mayor = abs(nro_2)', 'else:', 'menor = abs(nro_2)', 'mayor = abs(nro_1)', '', 'if menor == mayor == 0:   ', 'devovler = -1', 'elif menor == 0:', 'devolver = mayor', 'else:                     ', 'dividendo = mayor', 'divisor = menor', 'resto = mayor % divisor', '', 'while resto != 0:', 'dividendo = divisor', 'divisor = resto', 'resto = dividendo % divisor', '', 'devolver = divisor', '', 'return devolver', ''
mcm,'(nro_1, nro_2)', 'lib_matematica.py', 'return (nro_1 * nro_2)//mcd(nro_1, nro_2)', ''
menor_funcion,'(lineas)', 'modulo_merge.py', 'dato_menor = min(lineas)', 'return dato_menor[0]', ''
menu_MCD,'()', 'app_matematica.py', 'print("\\nMCD (Maximo comun divisor)")', 'valor_1 = solicitar_valor("Numero 1: ", -100000, 100000 )', 'valor_2 = solicitar_valor("Numero 2: ", -100000, 100000 )', 'print("El MCD es: ", lib_matematica.mcd(valor_1, valor_2), "\\n")', ''
menu_MCM,'()', 'app_matematica.py', 'print("\\nMCM (Minimo comun multiplo)")', 'valor_1 = solicitar_valor("Numero 1: ", -100000, 100000 )', 'valor_2 = solicitar_valor("Numero 2: ", -100000, 100000 )', 'print("El MCM es: ", lib_matematica.mcm(valor_1, valor_2), "\\n")', ''
menu_elegir,'()', 'app_matematica.py', 'menu_opciones()', 'opcion = solicitar_valor("Opcion: ", 1, 6)', 'print("-------------------------------")', 'while opcion != 6:', 'if opcion == 1:', 'menu_factorial()', 'elif opcion == 2:', 'menu_potencia()', 'elif opcion == 3:', 'menu_primo()', 'elif opcion == 4:', 'menu_MCD()', 'else:', 'menu_MCM()', 'menu_opciones()', 'opcion = solicitar_valor("Opcion: ", 1, 6)', 'print("-------------------------------")', ''
menu_factorial,'()', 'app_matematica.py', 'print("\\nCalculo de Factorial")', 'valor = solicitar_valor("Numero: ", 0, 20)', 'print("El factorial es: ", lib_matematica.factorial(valor), "\\n")', ''
menu_opciones,'()', 'app_matematica.py', 'print("-------------------------------")', 'print("MENU DE OPERACIONES MATEMATICAS")', 'print()', 'print("1. Factorial")', 'print("2. Potencia")', 'print("3. Primo")', 'print("4. MCD (Maximo Comun Divisor)")', 'print("5. MCM (Minimo Comun Multiplo)")', 'print("6. Terminar")', 'print()', ''
menu_potencia,'()', 'app_matematica.py', 'print("\\nCalculo de Potencia")', 'base = solicitar_valor("Base: ", -100, 100)', 'exponente = solicitar_valor("Exponente: ", -100, 100)', 'print("La potencia es: ", lib_matematica.potencia(base, exponente), "\\n")', ''
menu_primo,'()', 'app_matematica.py', 'print("\\nEvaluar Primo")', 'valor = solicitar_valor("Numero: ", -100000, 100000)', 'print("Es Primo\\n" if lib_matematica.es_primo(valor) else "No es primo\\n")', ''
merge,'(arch_salida, *archs_entrada)', 'modulo_merge.py', 'lineas = leer_lineas(archs_entrada)', 'menor = menor_funcion(lineas)', '', 'while menor < MAX_NOM_FUNCION:', 'for i in range(len(lineas)):', '', 'nom_funcion, *extras = lineas[i]', '', 'while nom_funcion == menor:', 'guardar(arch_salida, nom_funcion, extras)', 'nom_funcion, *extras = leer(archs_entrada[i])', '', 'lineas[i] = [nom_funcion, *extras]', '', 'menor = menor_funcion(lineas)', '', ''
ordenar_dict,'(diccionario)', 'generador_csv.py', 'dic_ordenado = dict(sorted(diccionario.items()))', 'return dic_ordenado', '', ''
ordered_list,'(lista)', '6-show-capicuas-ordered-unrepeated.py', '', 'sorted_list = sorted(lista, key=str.lower)', 'return sorted_list', '', ''
otros_coments,'(lista_comentarios)', 'generador_csv.py', 'lista_coments = []', 'for h in range(len(lista_comentarios)):', 'if not "autor" in lista_comentarios[h].lower() and not "ayuda" in lista_comentarios[h].lower() and lista_comentarios[h].lstrip(" ").rstrip("\\n") != comentario_multiple:', 'lista_coments.append(lista_comentarios[h].lstrip(" ").rstrip("\\n"))', 'return lista_coments', ''
potencia,'(base, exponente)', 'lib_matematica.py', '', 'resultado = base', 'for i in range(2, abs(exponente) +1):', 'resultado *= base', '', 'if exponente == 0:', 'resultado = 1', 'elif exponente < 0:', 'resultado = 1 / resultado', '', 'return resultado', ''
solicitar_valor,'(mensaje, minimo, maximo)', 'app_matematica.py', 'valor = input(mensaje)', 'while (not valor.isdigit()) or ((int(valor) < minimo) or (int(valor) > maximo)):', 'print("Error: Valor debe estar entre", minimo, "y", maximo)', 'valor = input(mensaje)', '', 'return int(valor)', ''
